{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport * as React from 'react';\nimport TextInput from \"react-native-web/dist/exports/TextInput\";\nimport Keyboard from \"react-native-web/dist/exports/Keyboard\";\nvar KeyboardManager = function (_React$Component) {\n  function KeyboardManager() {\n    var _this;\n    _classCallCheck(this, KeyboardManager);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _callSuper(this, KeyboardManager, [].concat(args));\n    _defineProperty(_this, \"previouslyFocusedTextInput\", undefined);\n    _defineProperty(_this, \"startTimestamp\", 0);\n    _defineProperty(_this, \"keyboardTimeout\", void 0);\n    _defineProperty(_this, \"clearKeyboardTimeout\", function () {\n      if (_this.keyboardTimeout !== undefined) {\n        clearTimeout(_this.keyboardTimeout);\n        _this.keyboardTimeout = undefined;\n      }\n    });\n    _defineProperty(_this, \"handlePageChangeStart\", function () {\n      if (!_this.props.enabled) {\n        return;\n      }\n      _this.clearKeyboardTimeout();\n      var input = TextInput.State.currentlyFocusedInput ? TextInput.State.currentlyFocusedInput() : TextInput.State.currentlyFocusedField();\n      TextInput.State.blurTextInput(input);\n      _this.previouslyFocusedTextInput = input;\n      _this.startTimestamp = Date.now();\n    });\n    _defineProperty(_this, \"handlePageChangeConfirm\", function (force) {\n      if (!_this.props.enabled) {\n        return;\n      }\n      _this.clearKeyboardTimeout();\n      if (force) {\n        Keyboard.dismiss();\n      } else {\n        var input = _this.previouslyFocusedTextInput;\n        if (input) {\n          TextInput.State.blurTextInput(input);\n        }\n      }\n      _this.previouslyFocusedTextInput = undefined;\n    });\n    _defineProperty(_this, \"handlePageChangeCancel\", function () {\n      if (!_this.props.enabled) {\n        return;\n      }\n      _this.clearKeyboardTimeout();\n      var input = _this.previouslyFocusedTextInput;\n      if (input) {\n        if (Date.now() - _this.startTimestamp < 100) {\n          _this.keyboardTimeout = setTimeout(function () {\n            TextInput.State.focusTextInput(input);\n            _this.previouslyFocusedTextInput = undefined;\n          }, 100);\n        } else {\n          TextInput.State.focusTextInput(input);\n          _this.previouslyFocusedTextInput = undefined;\n        }\n      }\n    });\n    return _this;\n  }\n  _inherits(KeyboardManager, _React$Component);\n  return _createClass(KeyboardManager, [{\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.clearKeyboardTimeout();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.props.children({\n        onPageChangeStart: this.handlePageChangeStart,\n        onPageChangeConfirm: this.handlePageChangeConfirm,\n        onPageChangeCancel: this.handlePageChangeCancel\n      });\n    }\n  }]);\n}(React.Component);\nexport { KeyboardManager as default };","map":{"version":3,"names":["React","TextInput","Keyboard","KeyboardManager","_React$Component","_this","_classCallCheck","_len","arguments","length","args","Array","_key","_callSuper","concat","_defineProperty","undefined","keyboardTimeout","clearTimeout","props","enabled","clearKeyboardTimeout","input","State","currentlyFocusedInput","currentlyFocusedField","blurTextInput","previouslyFocusedTextInput","startTimestamp","Date","now","force","dismiss","setTimeout","focusTextInput","_inherits","_createClass","key","value","componentWillUnmount","render","children","onPageChangeStart","handlePageChangeStart","onPageChangeConfirm","handlePageChangeConfirm","onPageChangeCancel","handlePageChangeCancel","Component","default"],"sources":["/Users/mauricioescudero/campusparking/MovApp/node_modules/@react-navigation/stack/lib/module/views/KeyboardManager.tsx"],"sourcesContent":["import * as React from 'react';\nimport { TextInput, Keyboard, HostComponent } from 'react-native';\n\ntype Props = {\n  enabled: boolean;\n  children: (props: {\n    onPageChangeStart: () => void;\n    onPageChangeConfirm: (force: boolean) => void;\n    onPageChangeCancel: () => void;\n  }) => React.ReactNode;\n};\n\ntype InputRef = React.ElementRef<HostComponent<unknown>> | undefined;\n\nexport default class KeyboardManager extends React.Component<Props> {\n  componentWillUnmount() {\n    this.clearKeyboardTimeout();\n  }\n\n  // Numeric id of the previously focused text input\n  // When a gesture didn't change the tab, we can restore the focused input with this\n  private previouslyFocusedTextInput: InputRef = undefined;\n  private startTimestamp: number = 0;\n  private keyboardTimeout: any;\n\n  private clearKeyboardTimeout = () => {\n    if (this.keyboardTimeout !== undefined) {\n      clearTimeout(this.keyboardTimeout);\n      this.keyboardTimeout = undefined;\n    }\n  };\n\n  private handlePageChangeStart = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    // @ts-expect-error: blurTextInput accepts both number and ref, but types say only ref\n    const input: InputRef = TextInput.State.currentlyFocusedInput\n      ? TextInput.State.currentlyFocusedInput()\n      : TextInput.State.currentlyFocusedField();\n\n    // When a page change begins, blur the currently focused input\n    TextInput.State.blurTextInput(input);\n\n    // Store the id of this input so we can refocus it if change was cancelled\n    this.previouslyFocusedTextInput = input;\n\n    // Store timestamp for touch start\n    this.startTimestamp = Date.now();\n  };\n\n  private handlePageChangeConfirm = (force: boolean) => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    if (force) {\n      // Always dismiss input, even if we don't have a ref to it\n      // We might not have the ref if onPageChangeStart was never called\n      // This can happen if page change was not from a gesture\n      Keyboard.dismiss();\n    } else {\n      const input = this.previouslyFocusedTextInput;\n\n      if (input) {\n        // Dismiss the keyboard only if an input was a focused before\n        // This makes sure we don't dismiss input on going back and focusing an input\n        TextInput.State.blurTextInput(input);\n      }\n    }\n\n    // Cleanup the ID on successful page change\n    this.previouslyFocusedTextInput = undefined;\n  };\n\n  private handlePageChangeCancel = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    // The page didn't change, we should restore the focus of text input\n    const input = this.previouslyFocusedTextInput;\n\n    if (input) {\n      // If the interaction was super short we should make sure keyboard won't hide again.\n\n      // Too fast input refocus will result only in keyboard flashing on screen and hiding right away.\n      // During first ~100ms keyboard will be dismissed no matter what,\n      // so we have to make sure it won't interrupt input refocus logic.\n      // That's why when the interaction is shorter than 100ms we add delay so it won't hide once again.\n      // Subtracting timestamps makes us sure the delay is executed only when needed.\n      if (Date.now() - this.startTimestamp < 100) {\n        this.keyboardTimeout = setTimeout(() => {\n          TextInput.State.focusTextInput(input);\n          this.previouslyFocusedTextInput = undefined;\n        }, 100);\n      } else {\n        TextInput.State.focusTextInput(input);\n        this.previouslyFocusedTextInput = undefined;\n      }\n    }\n  };\n\n  render() {\n    return this.props.children({\n      onPageChangeStart: this.handlePageChangeStart,\n      onPageChangeConfirm: this.handlePageChangeConfirm,\n      onPageChangeCancel: this.handlePageChangeCancel,\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}